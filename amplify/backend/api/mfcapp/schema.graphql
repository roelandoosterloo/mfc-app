type Profile
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin"] }, 
    { allow: private, provider: iam },
    { allow: owner, ownerField: "cognitoId" }]) {
  id: ID!
  cognitoId: String!
  firstName: String
  lastName: String
  email: String
}
type Enrollment
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin"] }, 
    { allow: private, provider: iam },
    { allow: owner, ownerField: "cognitoId" }]) 
  @key(name: "ofCourse" fields: ["courseId"] ){
  id: ID!
  cognitoId: ID!
  courseId: ID!
  startDate: AWSDateTime!
  course: Course @connection(fields: ["courseId"])
  moduleSchedule: [ModuleProgress!] @connection(keyName: "ofEnrollment", fields: ["id"])
}
type ModuleProgress 
  @model 
  @auth(rules: [
    { allow: groups, groups: ["admin"] }, 
    { allow: private, provider: iam },
    { allow: private, operations: [read] }])
  @key(name: "ofEnrollment", fields: ["enrollmentId"]){
  moduleId: ID!
  enrollmentId: ID!
  availableAt: AWSDateTime!
  module: Module @connection(fields: ["moduleId"])
}
type Course
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin"] },
    { allow: private, provider: iam } ,
    { allow: private, operations: [read] }]) {
  id: ID!
  accessGroup: String!
  name: String!
  description: String
  coverImage: String
  modules: [Module!] @connection( keyName: "ofCourse", fields: ["id"] )
}
type Module
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin"] },
    { allow: private, provider: iam },
    { allow: private, operations: [read] }])
  @key(name: "ofCourse", fields: ["courseId"]) {
  id: ID!
  courseId: ID!
  name: String!
  index: Int
  description: String!
  coverImage: String
  videoUrl: String!
  delayNumber: Int!
  delayUOM: String!
  assignments: [Question!] @connection( keyName: "ofModule", fields: ["id"] )
}
enum QuestionType {
  SHORT_TEXT
  LONG_TEXT
  SINGLE_CHOICE
  MULTIPLE_CHOICE
}
type Question
  @model 
  @auth(rules: [
    {allow: groups, groups: ["admin"]},
    { allow: private, provider: iam },
    { allow: private, operations: [read]}])
  @key(name: "ofModule", fields: ["moduleId"]) {
  id: ID!
  moduleId: ID!
  index: Int!
  type: QuestionType!
  question: String!
  introduction: String
  options: [Option!] @connection( keyName: "ofQuestion", fields: ["id"] )
}

type Option 
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin"] }, 
    { allow: private, provider: iam },
    { allow: private, operations: [read]}]) 
  @key(name: "ofQuestion", fields: ["questionId"] ){
  id: ID!
  questionId: ID!
  label: String!
}
type Measurement
  @model 
  @auth(rules: [
    { allow: owner },
    { allow: private, provider: iam },
    { allow: groups, groups: ["admin"] }
  ]) {
  id: ID!
  date: AWSDate!
  weight: Float!
  note: String
}
enum ContentState {
  LIVE
  DRAFT
  PENDING
  OFFLINE
}
type Recipe
  @model
  @auth(rules: [
    {allow: groups, groups: ["admin"]}, 
    { allow: private, operations: [read]}
  ]) {
    id: ID!
    date: AWSDate!
    state: ContentState!
    name: String!
    totalMinutes: Int!
    preparationMinutes: Int!
    imageUrl: String!
    instructionVideoUrl: String
    steps: [RecipeStep!] @connection( keyName: "forRecipe", fields: ["id"])
    ingredients: [Ingredient!] @connection( keyName: "forRecipe", fields: ["id"])
  }
type Ingredient
  @model
  @auth(rules: [{allow: groups, groups: ["admin"]}, { allow: private, operations: [read]}]) 
  @key(name: "forRecipe", fields: ["recipeId"])
  @key(name: "forProduct", fields: ["productId"]){
    id: ID!
    recipeId: ID!
    productId: ID!
    amount: Float!
    unit: Unit! @connection
    recipe: Recipe! @connection(fields: ["recipeId"])
    product: Product! @connection(fields: ["productId"])
  }
type Product
  @model
  @auth(rules: [{allow: groups, groups: ["admin"]}, { allow: private, operations: [read]}]) {
    id: ID!
    name: String!
    namePlural: String!
    ingredients: [Ingredient!] @connection(keyName: "forProduct", fields: ["id"])
  }
type Unit
  @model 
  @auth(rules: [{allow: groups, groups: ["admin"]}, { allow: private, operations: [read]}]) {
    id: ID!
    name: String!
    sign: String
  }
type RecipeStep
  @model 
  @auth(rules: [{allow: groups, groups: ["admin"]}, { allow: private, operations: [read]}]) 
  @key(name: "forRecipe", fields: ["recipeId"]) {
    id: ID!
    recipeId: ID!
    index: Int!
    instructionText: String!
  }

type Query  {
  adminListUsers: [CognitoUser] 
    @function(name: "mfcAppLambda-${env}") 
    @auth(rules: [{allow: groups, groups:["admin"]}])
  adminListGroups: [CognitoGroup] 
    @function(name: "mfcAppLambda-${env}")
    @auth(rules: [{allow: groups, groups:["admin"]}])
  adminGetUser(username: String): CognitoUser
    @function(name: "mfcAppLambda-${env}")
    @auth(rules: [{allow: groups, groups: ["admin"]}])
}

type Mutation {
  adminCreateUser(email: String, firstName: String, lastName: String ): CognitoUser 
    @function(name: "mfcAppLambda-${env}")
    @auth(rules: [{allow: groups, groups:["admin"]}])
  adminDeleteUser(username: String): Boolean 
    @function(name: "mfcAppLambda-${env}")
    @auth(rules: [{allow: groups, groups:["admin"]}])
  adminAddUserToGroup(username: String, groupName: String): Boolean 
    @function(name: "mfcAppLambda-${env}")
    @auth(rules: [{allow: groups, groups:["admin"]}])
  subscribeUser(username: String, courseId: String, startDate: AWSDateTime): Boolean 
    @function(name: "mfcAppLambda-${env}")
    @auth(rules: [{allow: groups, groups:["admin"]}])
}

type CognitoGroup {
  GroupName: String
  Description: String
  Precedence: Int
  LastMOdifiedDate: String
  CreationDate: String
}

type CognitoUser {
  Username: String!
  Attributes: [Value]
  UserCreateDate: String
  UserLastModifiedDate: String
  Enabled: Boolean
  UserStatus: UserStatus
  MFAOptions: [MFAOption]
  PreferredMfaSetting: String
  UserMFASettingList: String
}
type Value {
  Name: String!
  Value: String
}
type MFAOption {
  DeliveryMedium: String
  AttributeName: String
}
enum UserStatus {
  UNCONFIRMED
  CONFIRMED
  ARCHIVED
  COMPROMISED
  UNKNOWN
  RESET_REQUIRED
  FORCE_CHANGE_PASSWORD
}